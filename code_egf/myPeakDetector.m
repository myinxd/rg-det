function [PSlist] = myPeakDetector(ImgIn, ElpPara,PeakThrs, MaxDist)
% [PSlist] = myPeakDetector(ImgIn, GaussPara,PeakThrs, MinDist)
% This code detect the potential point sources
% ImgIn: the image smoothed by Gaussian ellipse filter
% ElpPara: parameter group of ellipse, generated by function myGaussEllipse
% PeakThrs: threshold of peaks
% MaxDist: the maximum distance between two peaks
%
% Date: 2018/01/06
% Update: Add self-adaptive local region 

if nargin < 4
    MaxDist = max(ElpPara(1:2));
end

% Normalize the raw image
ImgNorm = myNormalizer(ImgIn);

% Expand the raw image so as to detect peaks at the edge
[m,n] = size(ImgNorm);
Mat = zeros(m+2*MaxDist,n+2*MaxDist);
Mat(MaxDist+1:end-MaxDist,MaxDist+1:end-MaxDist) = ImgNorm;

Flag = 1;
RowIdx = [];ColIdx = [];Peaks = [];
Dists = [];
% Find peaks
while Flag
    [Max,Idx] = max(Mat(:));
    if (Max > PeakThrs)
        [RI,CI] = ind2sub(size(Mat),Idx);
        RowIdx = [RowIdx,RI]; ColIdx = [ColIdx,CI];Peaks = [Peaks,Max*length(Idx)];
        MinDist = round(MaxDist * (Max)); % Distance changes according to the peak value
        Dists = [Dists, MinDist*length(Idx)];
        for i = 1 : length(Idx)
            TempMat = Mat(RI(i) - MinDist:RI(i)+MinDist,CI(i)-MinDist:CI(i)+MinDist) ;
            Min = min(TempMat(:));
            Mat(RI(i) - MinDist:RI(i)+MinDist,CI(i)-MinDist:CI(i)+MinDist) = Min;
        end
    else
        Flag = 0;
    end
end
RowIdx = RowIdx - MaxDist;
ColIdx = ColIdx - MaxDist;

ElpParaRep = repmat(ElpPara,length(RowIdx),1);
PSlist = [ColIdx',RowIdx',Dists',ElpParaRep,Peaks'];



